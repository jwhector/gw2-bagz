// prisma/seed.ts

import { PrismaClient, ItemType } from '@prisma/client';
import fs from 'fs'; // Node.js file system module
import path from 'path'; // Node.js path module

// Instantiate Prisma Client
const prisma = new PrismaClient();

// --- Configuration ---

// Path to the JSON file generated by the Python extraction script
const JSON_DATA_FILE = path.join(__dirname, '..', 'extracted_gw2_data.json'); // Assumes JSON is in project root

// Type definition for the structure within the JSON file
interface ExtractedItemData {
  source_item_guesses: {
    name_guess: string;
    id_placeholder: number; // This is always 0 in the JSON
    type_guess: 'CONTAINER' | 'SALVAGEABLE';
  };
  extracted_sample_size: number;
  result_items: {
    id: number | null; // ID might be null if not found/parsed
    name: string;
    quantity: number;
  }[];
}

async function main() {
  console.log(`Starting database seed from ${path.basename(JSON_DATA_FILE)}...`);

  // 1. Read the JSON data file
  let allExtractedData: Record<string, ExtractedItemData>;
  try {
    const jsonData = fs.readFileSync(JSON_DATA_FILE, 'utf8');
    allExtractedData = JSON.parse(jsonData);
  } catch (error) {
    console.error(`Error reading or parsing JSON file (${JSON_DATA_FILE}):`, error);
    console.error('Please ensure the file exists and is valid JSON, and run the Python extraction script first.');
    process.exit(1); // Exit if JSON cannot be read
  }

  const filenames = Object.keys(allExtractedData);
  if (filenames.length === 0) {
    console.warn('JSON data file is empty. No data to seed.');
    return;
  }

  console.log(`Found data for ${filenames.length} source items in JSON file.`);
  let sourceItemsProcessed = 0;
  let dropRecordsProcessed = 0;

  // 2. Process each source item entry from the JSON
  for (const filename of filenames) {
    console.log(`\nProcessing source item from file: ${filename}`);
    const itemData = allExtractedData[filename];

    // 2a. Get Manual Source Item ID (Crucial)

    const sourceItemId = itemData.source_item_guesses.id_placeholder;
    const sourceItemName = itemData.source_item_guesses.name_guess; // Use override or guess
    const sourceItemType = ItemType[itemData.source_item_guesses.type_guess]; // Use override or guess
    const sourceItemSampleSize = itemData.extracted_sample_size;

    if (sourceItemSampleSize <= 0) {
        console.warn(`  - Skipping ${filename}: Sample size is zero or invalid (${sourceItemSampleSize}).`);
        continue; // Skip if sample size is not positive
    }

    try {
      // 2c. Upsert Source Item
      const sourceItem = await prisma.sourceItem.upsert({
        where: { id: sourceItemId },
        update: {
          name: sourceItemName,
          sampleSize: sourceItemSampleSize,
          type: sourceItemType,
        },
        create: {
          id: sourceItemId,
          name: sourceItemName,
          sampleSize: sourceItemSampleSize,
          type: sourceItemType,
        },
      });
      console.log(`  Upserted SourceItem: ${sourceItem.name} (ID: ${sourceItem.id}, SampleSize: ${sourceItem.sampleSize})`);
      sourceItemsProcessed++;

      // 2d. Process and Upsert Result Items and Drop Records
      let itemDropRecordsProcessed = 0;
      for (const result of itemData.result_items) {
        if (result.id === null || result.id === undefined) {
          console.warn(`  - Skipping result item "${result.name}": Missing valid ID in JSON data.`);
          continue; // Skip if result item ID is missing/null
        }
        if (!result.name) {
            console.warn(`  - Skipping result item with ID ${result.id}: Missing name in JSON data.`);
            continue; // Skip if name is missing
        }
         if (result.quantity === null || result.quantity === undefined || result.quantity < 0) {
            console.warn(`  - Skipping result item "${result.name}" (ID: ${result.id}): Invalid or missing quantity (${result.quantity}).`);
            continue; // Skip if quantity is invalid
        }

        const resultItemId = result.id;
        const resultItemName = result.name;
        const totalQuantity = result.quantity;

        try {
          // Upsert Result Item (ensures it exists)
          const resultItem = await prisma.resultItem.upsert({
            where: { id: resultItemId },
            update: { name: resultItemName }, // Update name in case it changed
            create: { id: resultItemId, name: resultItemName },
          });

          // Upsert Drop Record
          await prisma.dropRecord.upsert({
            where: {
              sourceItemId_resultItemId: {
                sourceItemId: sourceItem.id,
                resultItemId: resultItem.id,
              },
            },
            update: { totalQuantity: totalQuantity },
            create: {
              sourceItemId: sourceItem.id,
              resultItemId: resultItem.id,
              totalQuantity: totalQuantity,
            },
          });
          itemDropRecordsProcessed++;

        } catch (innerError) {
          console.error(
            `  - Error processing drop record for ${resultItemName} (ID: ${resultItemId}) from ${sourceItem.name}:`,
            innerError
          );
        }
      } // End loop through result_items
      console.log(`  Processed ${itemDropRecordsProcessed} drop records for ${sourceItem.name}.`);
      dropRecordsProcessed += itemDropRecordsProcessed;

    } catch (outerError) {
      console.error(`  Error processing source item entry for ${filename}:`, outerError);
    } // End try-catch for source item processing

  } // End loop through filenames

  console.log(`\nDatabase seed finished.`);
  console.log(`Processed ${sourceItemsProcessed} source items.`);
  console.log(`Processed ${dropRecordsProcessed} total drop records.`);
}

// Execute the main function and handle potential errors
main()
  .catch((e) => {
    console.error('Error during database seed:', e);
    process.exit(1);
  })
  .finally(async () => {
    // Close the Prisma Client connection
    await prisma.$disconnect();
  });
